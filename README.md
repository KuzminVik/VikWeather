# VikWeather
VikWeather - простое приложение для android, написанное на Kotlin. Показывает прогноз погоды для любых географических координат на земном шаре. Данные предоставлены сервисом openweathermap.org

Приложение создано в 2021 году в учебных целях в процессе обучения на факультете андроид-разработки университета Geekbrains.   
Использованные технологии: Kotlin, MVP, Room, RxJava2, Moxy, Chicherone, Retrofit, Dagger2

Внимание, дизайн и красота не является лучшей стороной этого приложения.

### Архитектура
В приложении реализована архитектурная модель MVP для отделения логики отображения пользовательского интерфейса от бизнес-логики и логики получения данных.

Для упрощения реализации используется библиотека Moxy. В соответствии с подходом сингл-активити, приложение имеет одну базовую активити, управляющую туллбаром и навигацией. В фрейм-контейнер загружаются три экрана-фрагмента. Главный - экран показа погодных данных, второй - экран поиска, и третий - настройки приложения. Каждому фрагменту соответствует свой класс Presenter. Получением и подготовкой данных для Презентера занимается Репозиторий. За базу данных отвечает класс CacheDataSource, за api - NetworkDataSource.

Кстати, в качестве ViewBinding я использую написанный на котлине viewbindingdelegate отКирилла Розова.

### Api
Для получения погодных данных используется библиотека Retrofit2. Сервис погоды Openweather имеет своеобразное апи на бесплатном тарифе, приходится делать два запроса и комбинировать ответы сервера (отчасти дублирующиеся) для получения такого набора данных, которые показались мне необходимыми для моей модели. Точка входа в моем приложении это запрос погоды по названию города - приходит ответ с текущими погодными показателями, а так же географические широта и долгота. И уже запрос по координатам дает прогноз погоды на ближайшие 7 дней и почасовой прогноз на ближайшие 48 часов. 

### База данных, реактивность и асинхронность
В приложении используется компонент Room, управляющий встроенным в андроид SQLite. Полученные по сети данные сохраняются в базе данных в качестве кэша, время жизни которого составляет полчаса. В случае повторного запроса, следует проверка, устарел ли кэш, чтобы либо показать его из базы данных, либо обновить данные по сети. Запросы Room возвращают Single с данными либо Complilable - то есть используются потоки данных и шаблон наблюдатель библиотеки RxJava. В репозитории данные из сети или базы данных мапятся, оборачиваются в Observable. И доставляются в Презентер, где в соответствии с бизнес-логикой отправляются на экраны UI.

Для ассинхронной работы используется планировщик Schedulers из RxJava и стандартные mainThread и ioThread.

### Навигация
В соответствии с требованиями MVP, навигация должна находиться в слое с бизнес-логикой, но при этом в презентер нельзя предоставить Context. С этой проблемой справляется библиотека Chicherone.

### Внедрение зависимостей
Для уменьшения связности приложения и внедрения зависимостей используется библиотека Dagger2. Инжектятся компоненты Room, Retrofit и Chicherone, планировщик Scheduler, SharedPreferences, Репозиторий и оба источника данных - CacheDataSource и NetworkDataSource.

### Темы приложения
На экране настроек приложения реализовано переключение темной и светлой темы с помощью смены режимов пользовательского интерфейса Configuration.UI_MODE_NIGHT_MASK.

### И, кстати
Если у вас есть дельные замечания, буду признателен за ваши сообщения на https://t.me/VikSimurg
